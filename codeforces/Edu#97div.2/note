A:
顾客购买策略：
先买floor(x/a)个，然后买剩下来x % a个，如果x%a > a/2那么顾客直接就买一个
这个顾客购买范围是l,r，问是否存在一个a的取值使得都满足后面的那种情况2 * (x % a) > a
2 * (x - aq) > a
直接考虑a=r+1就可以了？
(q+1) * a > x > a * q + a/2
(2q+2) * a > 2 * x > a * (2q+1)
需要l to r每一个都满足，那么2 * l,  2 * r
l/a = r/a且为奇数
a min = r - l
r-l > 1 then ok ?


If l > r-l then ok

Let a = l-1
then when l >= 3, it's ok
B:
反转子序列的最小次数 使得整个序列是交替01序列
f[i] finished, then ? 
1.向前延伸 最大01序列这样g[i]
2.f[i] = min{f[j]} i-g[i] <= j < i
还要加一个状态表示结尾是0/1？

C:
给定一堆ti，然后每个ti要指定另外一个唯一的时间Ti（Ti之间不能相同），然后所有的Ti的和最小
其实大概思路应该随便加，然后贪心吗？
是不是可以采取并查集之类的思路？考虑现在已经放置的这一片，如果“连起来了”那么就合并下root，否则就只是维护下最左最右
D:

E:

F:

G:

H:

